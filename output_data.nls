; inputs: x (list of all x seen), y (list of all y), test_x (x for which we want to know new y) 
; outputs: the predicted y for the tested x
to-report least-squares [x y test_x]
  ; see https://www.mathsisfun.com/data/least-squares-regression.html
 
  ; if we only have one value, we cannot predict anything, so we just return the given y value
  if (length x <= 1) [
    report one-of y    
  ]
  
  
  let sum_xsquare (sum (map [i -> i * i] x))
  let sum_xy (sum (map * x y))
  
  let N (length x)
  
  let m  ( (N * sum_xy - sum x * sum y) / (N * sum_xsquare - (sum x) ^ 2 ))
  let b ((sum y - m * sum x) / N)
  
  let predicted_y ( m * test_x + b)
  
  report predicted_y
end  

 

 




to run-x-times
    
  type "\n" type "\n" type "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!NEW SET OF RUNS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" type "\n"
  type "Number of runs: "type runs type "\n"
  
  if (not is-number? runs)[
    print "Error: Number of runs must be a number (must be an integer)"
    stop
  ]
     
  
  if (runs < 1) [
    print "Error: Number of runs must be at least 1"
    stop
  ]
  
  if (runs - int runs != 0) [
    print "Error: Number of runs must be an integer number"
    stop
  ]
 
  
    
  type "Current run: "type current_run type "\n"
  ; do one run (setup and go)
  
  setup
 
  
  ; RUN THE FIRST ITERATION
  set current_run 0

  while [not run_done?] [
      go
   ]
  
  set current_run 1
  
  ; KEEP DOING RUNS UNTIL THE REQUIRED AMOUNT OF RUNS IS REACHED
  ; for all runs after this we just need to reset the model, not setup new  
  while [current_run < runs] [
    type "Current run: "type current_run type "\n"
    
    reset
    
    
    ; run go until that specific run is done
    while [not run_done?] [
      go
    ]

     
    set current_run (current_run + 1)
    
  ]
  
  PRINT ""
  print "reached end"
  
  stop
  
  
  
  
end


